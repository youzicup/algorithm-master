# 203. ç§»é™¤é“¾è¡¨å…ƒç´ 
[åŽŸé¢˜é“¾æŽ¥ðŸ”—](https://leetcode-cn.com/problems/remove-linked-list-elements/)

ç»™ä½ ä¸€ä¸ªé“¾è¡¨çš„å¤´èŠ‚ç‚¹ `head` å’Œä¸€ä¸ªæ•´æ•° `val` ï¼Œè¯·ä½ åˆ é™¤é“¾è¡¨ä¸­æ‰€æœ‰æ»¡è¶³ `Node.val == val` çš„èŠ‚ç‚¹ï¼Œå¹¶è¿”å›ž `æ–°çš„å¤´èŠ‚ç‚¹` ã€‚

## è§£é¢˜æ€è·¯
åŸºç¡€é¢˜ï¼Œè€ƒå¯Ÿé“¾è¡¨çš„åˆ é™¤æ“ä½œã€‚

æ­¤å¤„çš„é“¾è¡¨æ˜¯æ²¡æœ‰ç©ºå¤´ç»“ç‚¹çš„é“¾è¡¨ï¼Œå³å¤´ç»“ç‚¹ä¹Ÿæ˜¯æ•°æ®ç»“ç‚¹ã€‚

ä»Žå¤´ç»“ç‚¹å‘åŽéåŽ†ï¼Œç¬¦åˆæ¡ä»¶ç»“ç‚¹åˆ é™¤å³å¯ï¼Œéœ€è¦æ³¨æ„ä»¥ä¸‹å‡ ç§ç‰¹æ®Šæƒ…å†µï¼š

 - ç©ºé“¾è¡¨
 - å¤´ç»“ç‚¹éœ€è¦åˆ é™¤
 - å°¾ç»“ç‚¹éœ€è¦åˆ é™¤

 å°†å¤´ç»“ç‚¹å¤„ç†å®Œæ¯•åŽå¯¹å‰©ä½™ç»“ç‚¹è¿›è¡Œå¤„ç†ï¼Œåˆ™å¯¹nextè¿›è¡Œåˆ¤å®šå³å¯ï¼Œç”±æ­¤å¾—åˆ°è§£æ³•ä¸€ã€‚

 è§£æ³•äºŒåœ¨è§£æ³•ä¸€çš„åŸºç¡€ä¸Šåšäº†é¢„å¤„ç†ï¼Œè®¾ç½®äº†è™šæ‹Ÿå¤´ç»“ç‚¹ï¼ŒçœåŽ»äº†åŽç»­å¯¹å¤´ç»“ç‚¹çš„ç‰¹æ®Šå¤„ç†ï¼Œè¿™æ˜¯æ— è™šæ‹Ÿå¤´ç»“ç‚¹çš„é“¾è¡¨çš„ä¸€ç§å¸¸è§å¤„ç†æ–¹å¼ã€‚

 æ­¤æ—¶éœ€è¦æ³¨æ„è¿”å›žçš„å¤´ç»“ç‚¹åº”è¯¥æ˜¯è™šæ‹Ÿå¤´ç»“ç‚¹ `dummy` çš„ `next` ç»“ç‚¹ã€‚

#### å¤æ‚åº¦åˆ†æž
 - æ—¶é—´å¤æ‚åº¦ $O(n)$ ã€‚
 - ç©ºé—´å¤æ‚åº¦ $O(1)$ ã€‚

## ä»£ç å®žçŽ°

**C++ï¼š**

è§£æ³•ä¸€ï¼š
```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
  ListNode* removeElements(ListNode* head, int val) {
    if(!head) return nullptr;
    // åˆ é™¤å¤´ç»“ç‚¹
    while(head && head->val == val) {
      ListNode* last = head;
      head = head->next;
      delete last;
    }
    ListNode* p = head;
    // åˆ é™¤éžå¤´ç»“ç‚¹
    while(p && p->next) {
      if(p->next->val != val) {
        p = p->next;
      } else {
        // è¿žç»­ç¬¦åˆçš„ç»“ç‚¹
        ListNode* last = p->next;
        p->next = p->next->next;
        delete last;
      }
    }
    return head;
  }
};
```

è§£æ³•äºŒï¼š
```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
  ListNode* removeElements(ListNode* head, int val) {
    if(!head) return NULL;
    ListNode* dummy = new ListNode(0);
    dummy->next = head;
    ListNode* p = dummy;
    // åˆ é™¤éžå¤´ç»“ç‚¹
    while(p && p->next) {
      if(p->next->val != val) {
        p = p->next;
      } else {
        // è¿žç»­ç¬¦åˆçš„ç»“ç‚¹
        ListNode* last = p->next;
        p->next = p->next->next;
        delete last;
      }
    }
    return dummy->next;
  }
};
```
