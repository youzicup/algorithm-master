# 2299. 强密码检验器 Ⅱ
[原题链接🔗](https://leetcode.cn/problems/strong-password-checker-ii/)

如果一个密码满足以下所有条件，我们称它是一个 `强` 密码：

 - 它有至少 `8` 个字符。
 - 至少包含 **一个小写英文** 字母。
 - 至少包含 **一个大写英文** 字母。
 - 至少包含 **一个数字** 。
 - 至少包含 **一个特殊字符** 。特殊字符为：`"!@#$%^&*()-+"` 中的一个。
 - 它 **不** 包含 `2` 个连续相同的字符（比方说 `"aab"` 不符合该条件，但是 `"aba"` 符合该条件）。

给你一个字符串 `password` ，如果它是一个 `强` 密码，返回 `true`，否则返回 `false` 。

## 解题思路
### 简单求解

本题为常规字符串处理题目，对于题目的各个条件分别判定后进行与运算即可。

注意以下使用的 `map初始化方式` 和 `map键值查找方式`。

本题题解区有不少简化代码的技巧，可以学习一下。

#### 复杂度分析
 - 时间复杂度 $O(n)$
 - 空间复杂度 $O(1)$


## 代码实现
**C++：**

```C++
#include <unordered_map>

class Solution {
public:
  bool strongPasswordCheckerII(string password) {
    bool len = false; // 长度检测
    bool lower = false, capital = false;  // 小写、大写检测
    bool num = false, special = false;    // 数字、特殊字符检测
    bool successive = true;  // 连续字符检测

    bool res = false;
    unordered_map<char, int> map = {
      {'!', 1}, {'@', 1}, {'#', 1}, {'$', 1},
      {'%', 1}, {'^', 1}, {'&', 1}, {'*', 1},
      {'(', 1}, {')', 1}, {'-', 1}, {'+', 1}
    };

    if(password.size() >= 8) len = true;
    for(int i = 0; i < password.size(); i++) {
      if(password[i] >= 'a' && password[i] <= 'z') lower = true;
      if(password[i] >= 'A' && password[i] <= 'Z') capital = true;
      if(password[i] >= '0' && password[i] <= '9') num = true;
      if(map.find(password[i]) != map.end()) special = true;    // 存在特殊字符
      if(i > 0 && password[i] == password[i - 1]) successive = false;
    }
    res = len & lower & capital & num & special & successive;
    return res;
  }
};
```
